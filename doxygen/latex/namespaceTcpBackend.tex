\hypertarget{namespaceTcpBackend}{}\section{Tcp\+Backend Namespace Reference}
\label{namespaceTcpBackend}\index{Tcp\+Backend@{Tcp\+Backend}}
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classTcpBackend_1_1Client}{Client}
\begin{DoxyCompactList}\small\item\em Used to start a connection. \end{DoxyCompactList}\item 
class \hyperlink{classTcpBackend_1_1ClientAsio}{Client\+Asio}
\item 
class \hyperlink{classTcpBackend_1_1Connection}{Connection}
\begin{DoxyCompactList}\small\item\em Represents a connection. \end{DoxyCompactList}\item 
class \hyperlink{classTcpBackend_1_1ConnectionAsio}{Connection\+Asio}
\item 
class \hyperlink{classTcpBackend_1_1Server}{Server}
\begin{DoxyCompactList}\small\item\em Used to accept new connections. \end{DoxyCompactList}\item 
class \hyperlink{classTcpBackend_1_1ServerAsio}{Server\+Asio}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{namespaceTcpBackend_a2c4e5e89eff1cb2603e717e037161b9b}{T\+CP} = asio\+::ip\+::tcp
\item 
using \hyperlink{namespaceTcpBackend_a7d2c9f63e8017af705255d4ed08264a7}{On\+Read} = std\+::function$<$ void(const std\+::uint8\+\_\+t $\ast$data, int len)$>$
\begin{DoxyCompactList}\small\item\em On\+Read callback. \end{DoxyCompactList}\item 
using \hyperlink{namespaceTcpBackend_a670c71abc926680e1ea574a5f3a99135}{On\+Write} = std\+::function$<$ void(void)$>$
\begin{DoxyCompactList}\small\item\em On\+Write callback. \end{DoxyCompactList}\item 
using \hyperlink{namespaceTcpBackend_a17e8f044749312a6692cd0135565cbc4}{On\+Error} = std\+::function$<$ void(const std\+::string \&message)$>$
\begin{DoxyCompactList}\small\item\em On\+Error callback. \end{DoxyCompactList}\item 
using \hyperlink{namespaceTcpBackend_afa30fa9a706436148fb2857a2174e625}{On\+Connected} = std\+::function$<$ void(std\+::unique\+\_\+ptr$<$ \hyperlink{classTcpBackend_1_1Connection}{Connection} $>$ \&\&connection, const std\+::string \&address, const std\+::string \&port)$>$
\begin{DoxyCompactList}\small\item\em On\+Connected callback. \end{DoxyCompactList}\item 
using \hyperlink{namespaceTcpBackend_a2ce9b1a1f46bfa6c4b1ad38c8aa262a6}{On\+Disconnected} = std\+::function$<$ void(void)$>$
\begin{DoxyCompactList}\small\item\em On\+Disconnected callback. \end{DoxyCompactList}\item 
using \hyperlink{namespaceTcpBackend_a8aed04c0b1d33eb06aec746da4452484}{On\+Accept} = std\+::function$<$ void(std\+::unique\+\_\+ptr$<$ \hyperlink{classTcpBackend_1_1Connection}{Connection} $>$ \&\&connection)$>$
\begin{DoxyCompactList}\small\item\em On\+Accept callback. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
std\+::unique\+\_\+ptr$<$ \hyperlink{classTcpBackend_1_1Client}{Client} $>$ \hyperlink{namespaceTcpBackend_ac561d1ab714a1b76b3db75b205dd4f84}{create\+\_\+client} (const std\+::string \&address, const std\+::string \&port, const \hyperlink{namespaceTcpBackend_afa30fa9a706436148fb2857a2174e625}{On\+Connected} \&on\+\_\+connected, const \hyperlink{namespaceTcpBackend_a17e8f044749312a6692cd0135565cbc4}{On\+Error} \&on\+\_\+error)
\begin{DoxyCompactList}\small\item\em Creates a T\+CP client. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \hyperlink{classTcpBackend_1_1Server}{Server} $>$ \hyperlink{namespaceTcpBackend_ad25ce62084f2e8ec8e6bd07d7510b7f2}{create\+\_\+server} (std\+::uint16\+\_\+t port, const \hyperlink{namespaceTcpBackend_a8aed04c0b1d33eb06aec746da4452484}{On\+Accept} \&on\+\_\+accept)
\begin{DoxyCompactList}\small\item\em Creates a T\+CP server. \end{DoxyCompactList}\item 
void \hyperlink{namespaceTcpBackend_ad949ba412696b6c7484f981fcb36a705}{run} ()
\begin{DoxyCompactList}\small\item\em Run the T\+CP backend. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\mbox{\Hypertarget{namespaceTcpBackend_a8aed04c0b1d33eb06aec746da4452484}\label{namespaceTcpBackend_a8aed04c0b1d33eb06aec746da4452484}} 
\index{Tcp\+Backend@{Tcp\+Backend}!On\+Accept@{On\+Accept}}
\index{On\+Accept@{On\+Accept}!Tcp\+Backend@{Tcp\+Backend}}
\subsubsection{\texorpdfstring{On\+Accept}{OnAccept}}
{\footnotesize\ttfamily using \hyperlink{namespaceTcpBackend_a8aed04c0b1d33eb06aec746da4452484}{Tcp\+Backend\+::\+On\+Accept} = typedef std\+::function$<$void(std\+::unique\+\_\+ptr$<$\hyperlink{classTcpBackend_1_1Connection}{Connection}$>$\&\& connection)$>$}



On\+Accept callback. 

Called by \hyperlink{classTcpBackend_1_1Server}{Server} when a new connection has been accepted


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em connection} & The new \hyperlink{classTcpBackend_1_1Connection}{Connection} \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceTcpBackend_afa30fa9a706436148fb2857a2174e625}\label{namespaceTcpBackend_afa30fa9a706436148fb2857a2174e625}} 
\index{Tcp\+Backend@{Tcp\+Backend}!On\+Connected@{On\+Connected}}
\index{On\+Connected@{On\+Connected}!Tcp\+Backend@{Tcp\+Backend}}
\subsubsection{\texorpdfstring{On\+Connected}{OnConnected}}
{\footnotesize\ttfamily using \hyperlink{namespaceTcpBackend_afa30fa9a706436148fb2857a2174e625}{Tcp\+Backend\+::\+On\+Connected} = typedef std\+::function$<$void(std\+::unique\+\_\+ptr$<$\hyperlink{classTcpBackend_1_1Connection}{Connection}$>$\&\& connection, const std\+::string\& address, const std\+::string\& port)$>$}



On\+Connected callback. 

Called by \hyperlink{classTcpBackend_1_1Client}{Client} when it has connected


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em connection} & The \hyperlink{classTcpBackend_1_1Connection}{Connection} that represents the connection \\
\hline
\mbox{\tt in}  & {\em address} & Address that the \hyperlink{classTcpBackend_1_1Connection}{Connection} is connected to \\
\hline
\mbox{\tt in}  & {\em port} & Port that the \hyperlink{classTcpBackend_1_1Connection}{Connection} is connected to \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceTcpBackend_a2ce9b1a1f46bfa6c4b1ad38c8aa262a6}\label{namespaceTcpBackend_a2ce9b1a1f46bfa6c4b1ad38c8aa262a6}} 
\index{Tcp\+Backend@{Tcp\+Backend}!On\+Disconnected@{On\+Disconnected}}
\index{On\+Disconnected@{On\+Disconnected}!Tcp\+Backend@{Tcp\+Backend}}
\subsubsection{\texorpdfstring{On\+Disconnected}{OnDisconnected}}
{\footnotesize\ttfamily using \hyperlink{namespaceTcpBackend_a2ce9b1a1f46bfa6c4b1ad38c8aa262a6}{Tcp\+Backend\+::\+On\+Disconnected} = typedef std\+::function$<$void(void)$>$}



On\+Disconnected callback. 

Called by \hyperlink{classTcpBackend_1_1Connection}{Connection} when the connection has closed and no more async tasks are ongoing.

The \hyperlink{classTcpBackend_1_1Connection}{Connection} instance may only be deleted when this callback has been called.

See  for more information. \mbox{\Hypertarget{namespaceTcpBackend_a17e8f044749312a6692cd0135565cbc4}\label{namespaceTcpBackend_a17e8f044749312a6692cd0135565cbc4}} 
\index{Tcp\+Backend@{Tcp\+Backend}!On\+Error@{On\+Error}}
\index{On\+Error@{On\+Error}!Tcp\+Backend@{Tcp\+Backend}}
\subsubsection{\texorpdfstring{On\+Error}{OnError}}
{\footnotesize\ttfamily using \hyperlink{namespaceTcpBackend_a17e8f044749312a6692cd0135565cbc4}{Tcp\+Backend\+::\+On\+Error} = typedef std\+::function$<$void(const std\+::string\& message)$>$}



On\+Error callback. 

Called by \hyperlink{classTcpBackend_1_1Connection}{Connection}, \hyperlink{classTcpBackend_1_1Client}{Client} or \hyperlink{classTcpBackend_1_1Server}{Server} when an error occurs


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em message} & The error message \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceTcpBackend_a7d2c9f63e8017af705255d4ed08264a7}\label{namespaceTcpBackend_a7d2c9f63e8017af705255d4ed08264a7}} 
\index{Tcp\+Backend@{Tcp\+Backend}!On\+Read@{On\+Read}}
\index{On\+Read@{On\+Read}!Tcp\+Backend@{Tcp\+Backend}}
\subsubsection{\texorpdfstring{On\+Read}{OnRead}}
{\footnotesize\ttfamily using \hyperlink{namespaceTcpBackend_a7d2c9f63e8017af705255d4ed08264a7}{Tcp\+Backend\+::\+On\+Read} = typedef std\+::function$<$void(const std\+::uint8\+\_\+t$\ast$ data, int len)$>$}



On\+Read callback. 

Called when the \hyperlink{classTcpBackend_1_1Connection}{Connection} has read data


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em data} & Pointer to data \\
\hline
\mbox{\tt in}  & {\em len} & Length of data \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceTcpBackend_a670c71abc926680e1ea574a5f3a99135}\label{namespaceTcpBackend_a670c71abc926680e1ea574a5f3a99135}} 
\index{Tcp\+Backend@{Tcp\+Backend}!On\+Write@{On\+Write}}
\index{On\+Write@{On\+Write}!Tcp\+Backend@{Tcp\+Backend}}
\subsubsection{\texorpdfstring{On\+Write}{OnWrite}}
{\footnotesize\ttfamily using \hyperlink{namespaceTcpBackend_a670c71abc926680e1ea574a5f3a99135}{Tcp\+Backend\+::\+On\+Write} = typedef std\+::function$<$void(void)$>$}



On\+Write callback. 

Called when the \hyperlink{classTcpBackend_1_1Connection}{Connection} has written queued data \mbox{\Hypertarget{namespaceTcpBackend_a2c4e5e89eff1cb2603e717e037161b9b}\label{namespaceTcpBackend_a2c4e5e89eff1cb2603e717e037161b9b}} 
\index{Tcp\+Backend@{Tcp\+Backend}!T\+CP@{T\+CP}}
\index{T\+CP@{T\+CP}!Tcp\+Backend@{Tcp\+Backend}}
\subsubsection{\texorpdfstring{T\+CP}{TCP}}
{\footnotesize\ttfamily typedef asio\+::ip\+::tcp \hyperlink{namespaceTcpBackend_a2c4e5e89eff1cb2603e717e037161b9b}{Tcp\+Backend\+::\+T\+CP}}



\subsection{Function Documentation}
\mbox{\Hypertarget{namespaceTcpBackend_ac561d1ab714a1b76b3db75b205dd4f84}\label{namespaceTcpBackend_ac561d1ab714a1b76b3db75b205dd4f84}} 
\index{Tcp\+Backend@{Tcp\+Backend}!create\+\_\+client@{create\+\_\+client}}
\index{create\+\_\+client@{create\+\_\+client}!Tcp\+Backend@{Tcp\+Backend}}
\subsubsection{\texorpdfstring{create\+\_\+client()}{create\_client()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \hyperlink{classTcpBackend_1_1Client}{Client} $>$ Tcp\+Backend\+::create\+\_\+client (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{address,  }\item[{const std\+::string \&}]{port,  }\item[{const \hyperlink{namespaceTcpBackend_afa30fa9a706436148fb2857a2174e625}{On\+Connected} \&}]{on\+\_\+connected,  }\item[{const \hyperlink{namespaceTcpBackend_a17e8f044749312a6692cd0135565cbc4}{On\+Error} \&}]{on\+\_\+error }\end{DoxyParamCaption})}



Creates a T\+CP client. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em address} & Address to connect on \\
\hline
\mbox{\tt in}  & {\em port} & Port to connect on \\
\hline
\mbox{\tt in}  & {\em on\+\_\+connected} & Callback that is called when the client has connected \\
\hline
\mbox{\tt in}  & {\em on\+\_\+error} & Callback that is called on error\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classTcpBackend_1_1Client}{Client} wrapped in std\+::unique\+\_\+ptr, or an empty std\+::unique\+\_\+ptr on error 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceTcpBackend_ad25ce62084f2e8ec8e6bd07d7510b7f2}\label{namespaceTcpBackend_ad25ce62084f2e8ec8e6bd07d7510b7f2}} 
\index{Tcp\+Backend@{Tcp\+Backend}!create\+\_\+server@{create\+\_\+server}}
\index{create\+\_\+server@{create\+\_\+server}!Tcp\+Backend@{Tcp\+Backend}}
\subsubsection{\texorpdfstring{create\+\_\+server()}{create\_server()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \hyperlink{classTcpBackend_1_1Server}{Server} $>$ Tcp\+Backend\+::create\+\_\+server (\begin{DoxyParamCaption}\item[{std\+::uint16\+\_\+t}]{port,  }\item[{const \hyperlink{namespaceTcpBackend_a8aed04c0b1d33eb06aec746da4452484}{On\+Accept} \&}]{on\+\_\+accept }\end{DoxyParamCaption})}



Creates a T\+CP server. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em port} & Port to listen on \\
\hline
\mbox{\tt in}  & {\em on\+\_\+accept} & Callback that is called when a client has connected\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classTcpBackend_1_1Server}{Server} wrapped in std\+::unique\+\_\+ptr, or an empty std\+::unique\+\_\+ptr on error 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceTcpBackend_ad949ba412696b6c7484f981fcb36a705}\label{namespaceTcpBackend_ad949ba412696b6c7484f981fcb36a705}} 
\index{Tcp\+Backend@{Tcp\+Backend}!run@{run}}
\index{run@{run}!Tcp\+Backend@{Tcp\+Backend}}
\subsubsection{\texorpdfstring{run()}{run()}}
{\footnotesize\ttfamily void Tcp\+Backend\+::run (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Run the T\+CP backend. 

Async tasks that have been started via calls to e.\+g. create\+\_\+client or create\+\_\+server will be handled in this call. This call will only return when there are no more active async tasks. 